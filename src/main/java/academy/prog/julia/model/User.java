package academy.prog.julia.model;

import academy.prog.julia.helpers.PhoneNumberValidator;
import academy.prog.julia.utils.EntityUtils;
import academy.prog.julia.utils.Utils;
import com.fasterxml.jackson.annotation.JsonIgnore;
import jakarta.persistence.*;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Pattern;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.hibernate.validator.constraints.Length;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;

import java.io.Serial;
import java.io.Serializable;
import java.time.LocalDateTime;
import java.util.*;

/**
 * Represents a user entity in the system.
 *
 * This class is mapped to the "clients" table in the database.
 * It uses single table inheritance strategy where all user types (e.g., Admin, Teacher, Manager) are
 * stored in one table. The discriminator column "role" is used to distinguish between different
 * user roles. The default discriminator value for this base class is "0".
 *
 * The User class implements the UserDetails interface from Spring Security to provide user-specific
 * information required for authentication and authorization. It also implements Serializable to
 * support object serialization.
 *
 * The following annotations are used:
 * - @Entity: Marks this class as a JPA entity.
 * - @Table(name = "clients"): Specifies the table name in the database.
 * - @Inheritance(strategy = InheritanceType.SINGLE_TABLE):
 *   Indicates that a single table will be used to manage all entities in the inheritance hierarchy.
 * - @DiscriminatorColumn(name = "role", discriminatorType = DiscriminatorType.INTEGER):
 *   Defines the column used for distinguishing between different subclasses in the table.
 * - @DiscriminatorValue("0"): Specifies the discriminator value for this base class, which is used
 *   to identify records of this type(it`s ROLE STUDENT)
 *
 */
@Entity
@Table(name = "clients")
@Inheritance(strategy = InheritanceType.SINGLE_TABLE)
@DiscriminatorColumn(name = "role", discriminatorType = DiscriminatorType.INTEGER)
@DiscriminatorValue("0")
public class User implements UserDetails, Serializable {

    /**
     * Ensure compatibility between different versions of the class
     */
    @Serial
    private static final long serialVersionUID = 1L;

    /**
     * Discriminator value for the base User class.
     */
    public static final int DISCRIMINATOR_VALUE = 0;

    private static final Logger LOGGER = LogManager.getLogger(User.class);

    /**
     * Unique identifier for the user.
     * This field is auto-generated by the database.
     */
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    /**
     * User's first name.
     * This field must not be empty and must match a specific pattern.
     * Length is restricted to a maximum of 255 characters.
     *
     * The pattern ensures the following:
     * - `^(?!.{31})`: The name cannot be longer than 30 characters (due to a negative lookahead assertion).
     * - `[A-Z]`: The name must start with an uppercase letter.
     * - `[a-z]{1,}`: After the first letter, it must be followed by at least one or more lowercase letters.
     * - `(-[A-Z][a-z]{1,})*$`: Optionally, the name can have hyphenated parts where each part starts with
     *              an uppercase letter followed by lowercase letters. The hyphen can occur multiple times.
     *
     * Examples of valid names: "John", "Mary-Jane".
     * Examples of invalid names: "john", "MARY-JANE", "John Doe", "John-12".
     */
    @Column(nullable = false)
    @NotBlank(message = "User name cannot be empty")
    @Pattern(regexp = "^(?!.{31})[A-Z][a-z]{1,}(-[A-Z][a-z]{1,})*$",
            message = "Invalid characters in name, only dashes, ' and less than 30 elements."
    )
    @Length(max = 255, message = "Message too long (limit - 255 B)")
    private String name;

    /**
     * User's surname.
     * This field must not be empty and must match a specific pattern.
     * Length is restricted to a maximum of 255 characters.
     *
     * The pattern ensures the following:
     * - `^(?!.{31})`: The surname cannot be longer than 30 characters (due to a negative lookahead assertion).
     * - `[A-Z]`: The surname must start with an uppercase letter.
     * - `[a-z]{1,}`: After the first letter, it must be followed by at least one or more lowercase letters.
     * - `(-[A-Z][a-z]{1,})*$`: Optionally, the surname can have hyphenated parts where each part starts with
     *                  an uppercase letter followed by lowercase letters. The hyphen can occur multiple times.
     *
     * Examples of valid surnames: "Smith", "O'Reilly".
     * Examples of invalid surnames: "smith", "SMITH", "Smith-123", "Smith Doe".
     */
    @Column(nullable = false)
    @NotBlank(message = "User surname cannot be empty")
    @Pattern(regexp = "^(?!.{31})[A-Z][a-z]{1,}(-[A-Z][a-z]{1,})*$",
            message = "Invalid characters in surname, only dashes, ' and less than 30 elements."
    )
    @Length(max = 255, message = "Message too long (limit - 255 B)")
    private String surname;

    /**
     * Date and time when the user registered.
     * This field is set to the current date and time when the user is created.
     */
    @Temporal(value = TemporalType.TIMESTAMP)
    @Column(name = "register_date", nullable = false)
    private LocalDateTime registerDate;

    /**
     * Telegram chat ID associated with the user.
     */
    @Column(name = "telegram_chatid")
    private String telegramChatId;

    /**
     * User's phone number.
     * This field must not be empty and must match a specific pattern.
     * Phone number should be unique and its length is restricted to a minimum of 9 and a maximum of 16 characters.
     *
     * The pattern ensures the following:
     * - `^(00\\d+|0\\d+|\\+\\d+)$`: The phone number can start with "00" followed by digits, "0" followed by
     *          digits, or "+" followed by digits. This accommodates international and local phone number formats.
     *
     * Examples of valid phone numbers: "+1234567890", "0123456789", "0044123456789".
     * Examples of invalid phone numbers: "12345", "abcdefgh", "1234-5678".
     */
    @Column(unique = true, nullable = false)
    @NotBlank(message = "User phone number cannot be empty")
    @Pattern(regexp = "^(00\\d+|0\\d+|\\+\\d+)$", message = "Invalid phone number format")
    @Length(min = 9, max = 16, message = "Number is short/long (limit - from 9 to 15 characters)")
    private String phone;

    /**
     * User's email address.
     * This field must not be empty and must match a specific pattern.
     * Email should be unique.
     *
     * The pattern ensures the following:
     * - `^(?![_-])(?!.*[_-]@)[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$`:
     *   - `^(?![_-])`: The email cannot start with underscores or hyphens.
     *   - `(?!.*[_-]@)`: The email cannot have underscores or hyphens before the '@' symbol.
     *   - `[a-zA-Z0-9._%+-]+`: The local part of the email (before '@') can contain letters, digits, dots,
     *                          percent signs, plus signs, and hyphens.
     *   - `@[a-zA-Z0-9.-]+`: The domain part (after '@') can contain letters, digits, dots, and hyphens.
     *   - `\\.[a-zA-Z]{2,}$`: The domain must end with a dot followed by at least two letters.
     *
     * Examples of valid emails: "user@example.com", "john.doe@example.co.uk".
     * Examples of invalid emails: "user@com", "user@-example.com", "user@.example.com".
     */
    @Column(unique = true, nullable = false)
    @NotBlank(message = "Email cannot be empty")
    @Pattern(regexp = "^(?![_-])(?!.*[_-]@)[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$",
            message = "Invalid email format. Only letters, numbers, dots, and one @ symbol are allowed.")
    private String email;

    /**
     * A unique identifier for the user.
     * This field is used for distinguishing between different users.
     */
    @Column(unique = true, nullable = false)
    private String uniqueId;

    /**
     * A set of phone numbers associated with the user.
     * This collection is eagerly fetched and its elements are unique.
     */
    @ElementCollection(fetch = FetchType.EAGER)
    @CollectionTable(name = "client_phones", joinColumns = @JoinColumn(name = "client_id"))
    @Column(name = "phone", unique = true)
    private Set<String> phones = new HashSet<>();

    /**
     * A set of email addresses associated with the user.
     * This collection is eagerly fetched and its elements are unique.
     */
    @ElementCollection(fetch = FetchType.EAGER)
    @CollectionTable(name = "client_emails", joinColumns = @JoinColumn(name = "client_id"))
    @Column(name = "email", unique = true)
    private Set<String> emails = new HashSet<>();

    /**
     * A many-to-many relationship with groups.
     * This collection represents the groups the user is associated with.
     * The collection is eagerly fetched and ignored during JSON serialization.
     */
    @ManyToMany(fetch = FetchType.EAGER)
    @JoinTable(
            name = "client_course",
            joinColumns = @JoinColumn(name = "client_id"),
            inverseJoinColumns = @JoinColumn(name = "course_id"))
    @JsonIgnore
    private Set<Group> groups = new HashSet<>();

    /**
     * A one-to-many relationship with certificates.
     * This collection represents the certificates issued to the user.
     * The collection is lazily fetched and ignored during JSON serialization.
     */
    @OneToMany(fetch = FetchType.LAZY, mappedBy = "user")
    @JsonIgnore
    private Set<Certificate> certificates = new HashSet<>();

    /**
     * Indicates whether the user is banned.
     */
    @Column(name = "is_banned")
    private Boolean isBanned = false;

    /**
     * A many-to-many relationship with tasks.
     * This collection represents the tasks assigned to the user.
     * The collection is eagerly fetched and ignored during JSON serialization.
     */
    @ManyToMany(fetch = FetchType.EAGER, mappedBy = "students")
    @JsonIgnore
    private Set<Task> tasks;

    /**
     * User's password.
     * This field must not be empty and is ignored during JSON serialization.
     */
    @NotBlank(message = "Password cannot be empty")
    @JsonIgnore
    private String password;

    /**
     * A one-to-many relationship with task answers.
     * This collection represents the answers the user has provided for tasks.
     * The collection is lazily fetched and ignored during JSON serialization.
     */
    @OneToMany(mappedBy = "user")
    @JsonIgnore
    private Set<TaskAnswer> taskAnswers = new HashSet<>();

    /**
     * A one-to-many relationship with test answers.
     * This collection represents the answers the user has provided for tests.
     * The collection is eagerly fetched and ignored during JSON serialization.
     */
    @OneToMany(mappedBy = "user", cascade = CascadeType.ALL)
    @JsonIgnore
    private Set<TestAnswer> testAnswers = new HashSet<>();

    /**
     * Indicates whether the user is active.
     */
    private Boolean isActive;

    /**
     * Default constructor required by JPA.
     */
    public User() {}

    /**
     * Parameterized constructor to initialize a User with specific values.
     *
     * @param name        The user's first name
     * @param surname     The user's surname
     * @param phone       The user's phone number
     * @param email       The user's email address
     * @param password    The user's password
     */
    public User(
            String name,
            String surname,
            String phone,
            String email,
            String password
    ) {
        this.name = name;
        this.surname = surname;
        this.email = email;
        this.password = password;

        this.phone = PhoneNumberValidator.validateAndNormalize(phone);
        if (this.phone == null) {
            LOGGER.info("phoneNumberError: {}", "Invalid phone number format!");
            throw new IllegalArgumentException("Invalid phone number format");
        }

        this.setRegisterDate(LocalDateTime.now());
        this.setUniqueId(Utils.hashStrings(name, surname, phone, email, password, LocalDateTime.now().toString()));
    }

    /**
     * Gets the role of the user based on the discriminator value.
     *
     * @return The role of the user
     */
    @Transient
    public UserRole getRole() {
        var discValue = getClass().getAnnotation(DiscriminatorValue.class).value();
        var index = Integer.parseInt(discValue);

        return UserRole.values()[index];
    }

    /**
     * Adds a phone number to the user's set of phone numbers.
     *
     * @param phone The phone number to add
     * @return True if the phone number was added, otherwise false
     */
    public boolean addPhone(String phone) {
        return phones.add(phone);
    }

    /**
     * Removes a phone number from the user's set of phone numbers.
     *
     * @param phone The phone number to remove
     * @return True if the phone number was removed, otherwise false
     */
    public boolean removePhone(String phone) {
        return phones.remove(phone);
    }

    /**
     * Adds an email address to the user's set of email addresses.
     *
     * @param email The email address to add
     * @return True if the email address was added, otherwise false
     */
    public boolean addEmail(String email) {
        return emails.add(email);
    }

    /**
     * Removes an email address from the user's set of email addresses.
     *
     * @param email The email address to remove
     * @return True if the email address was removed, otherwise false
     */
    public boolean removeEmail(String email) {
        return emails.remove(email);
    }

    /**
     * Adds a group to the user's set of groups.
     *
     * @param group The group to add
     * @return True if the group was added, otherwise false
     */
    public boolean addGroup(Group group) {
        return groups.add(group);
    }

    /**
     * Removes a group from the user's set of groups.
     *
     * @param group The group to remove
     * @return True if the group was removed, otherwise false
     */
    public boolean removeGroup(Group group) {
        return groups.remove(group);
    }

    /**
     * Adds a test answer to the user's set of test answers.
     * Also sets the user reference on the test answer.
     *
     * @param answer The test answer to add
     */
    public void addTestAnswerToUser(TestAnswer answer) {
        testAnswers.add(answer);
        answer.setUser(this);
    }

    /**
     * Removes a test answer from the user's set of test answers.
     *
     * @param answer The test answer to remove
     */
    public void removeTestAnswerFromUser(TestAnswer answer) {
        testAnswers.remove(answer);
    }

    /**
     * Returns the unique identifier of the user.
     *
     * @return The ID of the user.
     */
    public Long getId() {
        return id;
    }

    /**
     * Sets the unique identifier of the user.
     *
     * @param id The ID to set.
     */
    public void setId(Long id) {
        this.id = id;
    }

    /**
     * Returns the first name of the user.
     *
     * @return The name of the user.
     */
    public String getName() {
        return name;
    }

    /**
     * Sets the first name of the user.
     *
     * @param name The name to set.
     */
    public void setName(String name) {
        this.name = name;
    }

    /**
     * Returns the surname of the user.
     *
     * @return The surname of the user.
     */
    public String getSurname() {
        return surname;
    }

    /**
     * Sets the surname of the user.
     *
     * @param surname The surname to set.
     */
    public void setSurname(String surname) {
        this.surname = surname;
    }

    /**
     * Returns the registration date of the user.
     *
     * @return The registration date of the user.
     */
    public LocalDateTime getRegisterDate() {
        return registerDate;
    }

    /**
     * Sets the registration date of the user.
     *
     * @param registerDate The registration date to set.
     */
    public void setRegisterDate(LocalDateTime registerDate) {
        this.registerDate = registerDate;
    }

    /**
     * Returns the Telegram chat ID associated with the user.
     *
     * @return The Telegram chat ID of the user.
     */
    public String getTelegramChatId() {
        return telegramChatId;
    }

    /**
     * Sets the Telegram chat ID associated with the user.
     *
     * @param telegramChatId The Telegram chat ID to set.
     */
    public void setTelegramChatId(String telegramChatId) {
        this.telegramChatId = telegramChatId;
    }

    /**
     * Returns the set of phone numbers associated with the user.
     *
     * @return The set of phone numbers.
     */
    public Set<String> getPhones() {
        return phones;
    }

    /**
     * Sets the set of phone numbers associated with the user.
     *
     * @param phones The set of phone numbers to set.
     */
    public void setPhones(Set<String> phones) {
        this.phones = phones;
    }

    /**
     * Returns the set of email addresses associated with the user.
     *
     * @return The set of email addresses.
     */
    public Set<String> getEmails() {
        return emails;
    }

    /**
     * Sets the set of email addresses associated with the user.
     *
     * @param emails The set of email addresses to set.
     */
    public void setEmails(Set<String> emails) {
        this.emails = emails;
    }

    /**
     * Returns the set of groups associated with the user.
     *
     * @return The set of groups.
     */
    public Set<Group> getGroups() {
        return groups;
    }

    /**
     * Sets the set of groups associated with the user.
     *
     * @param groups The set of groups to set.
     */
    public void setGroups(Set<Group> groups) {
        this.groups = groups;
    }

    /**
     * Returns the phone number of the user.
     *
     * @return The phone number.
     */
    public String getPhone() {
        return phone;
    }

    /**
     * Returns the banned status of the user.
     *
     * @return The banned status.
     */
    public Boolean getBannedStatus() {
        return isBanned;
    }

    /**
     * Sets the banned status of the user.
     *
     * @param banned The banned status to set.
     */
    public void setBannedStatus(Boolean banned) {
        isBanned = banned;
    }

    /**
     * Sets the phone number of the user, validating and normalizing it.
     *
     * @param phone The phone number to set.
     * @throws IllegalArgumentException if the phone number format is invalid.
     */
    public void setPhone(String phone) {
        String normalizedPhone = PhoneNumberValidator.validateAndNormalize(phone);
        if (normalizedPhone != null) {
            this.phone = normalizedPhone;
        } else {
            LOGGER.info("phoneNumberError: {}", "Invalid phone number format!");
            throw new IllegalArgumentException("Invalid phone number format");
        }
    }

    /**
     * Returns the email address of the user.
     *
     * @return The email address.
     */
    public String getEmail() {
        return email;
    }

    /**
     * Sets the email address of the user.
     *
     * @param email The email address to set.
     */
    public void setEmail(String email) {
        this.email = email;
    }

    /**
     * Returns the unique ID of the user.
     *
     * @return The unique ID.
     */
    public String getUniqueId() {
        return uniqueId;
    }

    /**
     * Sets the unique ID of the user.
     *
     * @param uniqueId The unique ID to set.
     */
    public void setUniqueId(String uniqueId) {
        this.uniqueId = uniqueId;
    }

    /**
     * Returns the set of certificates associated with the user.
     *
     * @return The set of certificates.
     */
    public Set<Certificate> getCertificates() {
        return certificates;
    }

    /**
     * Sets the set of certificates associated with the user.
     *
     * @param certificates The set of certificates to set.
     */
    public void setCertificates(Set<Certificate> certificates) {
        this.certificates = certificates;
    }

    /**
     * Returns the set of tasks associated with the user.
     *
     * @return The set of tasks.
     */
    public Set<Task> getTasks() {
        return tasks;
    }

    /**
     * Sets the set of tasks associated with the user.
     *
     * @param tasks The set of tasks to set.
     */
    public void setTasks(Set<Task> tasks) {
        this.tasks = tasks;
    }

    /**
     * Returns the password of the user.
     *
     * @return The password.
     */
    public String getPassword() {
        return password;
    }

    /**
     * Sets the password of the user.
     *
     * @param password The password to set.
     */
    public void setPassword(String password) {
        this.password = password;
    }

    /**
     * Returns the set of task answers provided by the user.
     *
     * @return The set of task answers.
     */
    public Set<TaskAnswer> getTaskAnswers() {
        return taskAnswers;
    }

    /**
     * Sets the set of task answers provided by the user.
     *
     * @param taskAnswers The set of task answers to set.
     */
    public void setTaskAnswers(Set<TaskAnswer> taskAnswers) {
        this.taskAnswers = taskAnswers;
    }

    /**
     * Returns the active status of the user.
     *
     * @return The active status.
     */
    public Boolean getActive() {
        return isActive;
    }

    /**
     * Sets the active status of the user.
     *
     * @param active The active status to set.
     */
    public void setActive(Boolean active) {
        isActive = active;
    }

    /**
     * Returns the set of test answers provided by the user.
     *
     * @return The set of test answers.
     */
    public Set<TestAnswer> getTestAnswers() {
        return testAnswers;
    }

    /**
     * Provides the authorities granted to the user based on their role.
     *
     * @return A collection of granted authorities.
     */
    @Override
    public Collection<? extends GrantedAuthority> getAuthorities() {
        List<GrantedAuthority> authorities = new ArrayList<>();

        authorities.add(new SimpleGrantedAuthority(UserRole.STUDENT.toString()));

        if (this instanceof AdminUser) {
            authorities.add(new SimpleGrantedAuthority(UserRole.ADMIN.toString()));
        } else if (this instanceof TeacherUser) {
            authorities.add(new SimpleGrantedAuthority(UserRole.TEACHER.toString()));
        } else if (this instanceof ManagerUser) {
            authorities.add(new SimpleGrantedAuthority(UserRole.MANAGER.toString()));
        } else if (this instanceof MentorUser) {
            authorities.add(new SimpleGrantedAuthority(UserRole.MENTOR.toString()));
        }

        return authorities;
    }

    /**
     * Returns the username of the user, which is their email address.
     *
     * @return The email address of the user.
     */
    @Override
    public String getUsername() {
        return email;
    }

    /**
     * Indicates whether the user's account is non-expired.
     *
     * @return True, as this implementation considers the account always non-expired.
     */
    @Override
    public boolean isAccountNonExpired() {
        return true;
    }

    /**
     * Indicates whether the user's account is non-locked.
     *
     * @return True, as this implementation considers the account always non-locked.
     */
    @Override
    public boolean isAccountNonLocked() {
        return true;
    }

    /**
     * Indicates whether the user's credentials are non-expired.
     *
     * @return True, as this implementation considers the credentials always non-expired.
     */
    @Override
    public boolean isCredentialsNonExpired() {
        return true;
    }

    /**
     * Indicates whether the user is enabled.
     *
     * @return True if the user is active; otherwise, false.
     */
    @Override
    public boolean isEnabled() {
        return isActive = true;
    }

    /**
     * Returns a string representation of the user.
     *
     * @return A string describing the user.
     */
    @Override
    public String toString() {
        return "User{" +
                "id= " + id +
                ", name= " + name +
                ", surname= " + surname +
                ", phone= " + phone +
                ", email= " + email +
                ", RegisterDate= " + registerDate +
                ", UniqueId= " + uniqueId +
                "}"
        ;
    }

    /**
     * Checks if this user is equal to another object.
     *
     * @param o The object to compare to.
     * @return True if the objects are equal; otherwise, false.
     */
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        User user = (User) o;

        return Objects.equals(id, user.id) &&
                Objects.equals(name, user.name) &&
                Objects.equals(surname, user.surname) &&
                Objects.equals(registerDate, user.registerDate) &&
                Objects.equals(telegramChatId, user.telegramChatId) &&
                Objects.equals(phone, user.phone) &&
                Objects.equals(email, user.email) &&
                Objects.equals(uniqueId, user.uniqueId) &&
                Objects.equals(phones, user.phones) &&
                Objects.equals(emails, user.emails)
        ;
    }

    /**
     * Returns a hash code value for the user.
     *
     * @return The hash code of the user.
     */
    @Override
    public int hashCode() {
        return Objects.hash(
                id,
                name,
                surname,
                registerDate,
                telegramChatId,
                phone,
                email,
                uniqueId,
                phones,
                emails
        );
    }

}
