package academy.prog.julia.model;

import academy.prog.julia.utils.EntityUtils;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.mysql.cj.xdevapi.Client;
import jakarta.persistence.*;

import java.io.Serial;
import java.io.Serializable;
import java.time.LocalDateTime;
import java.util.Collections;
import java.util.HashSet;
import java.util.Objects;
import java.util.Set;

/**
 * Represents a study group in the database.
 *
 * This class maps to the 'study_groups' table and defines the structure of study group data.
 *
 * @Entity marks this class as a JPA entity to be managed by Hibernate
 */
@Entity
@Table(name = "study_groups")
public class Group implements Serializable {

    /**
     * Ensure compatibility between different versions of the class
     */
    @Serial
    private static final long serialVersionUID = 1L;

    /**
     * Unique identifier for the study group.
     *
     * This field is auto-generated by the database.
     */
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    /**
     * Name of the study group.
     *
     * This field must be unique and cannot be null.
     */
    @Column(nullable = false, unique = true)
    private String name;

    /**
     * Set of users associated with this study group.
     *
     * The 'clients' field represents a many-to-many relationship between Group and User entities,
     * fetch type EAGER - data always have adding to model during call it.
     * This field is marked to be ignored by JSON serialization.
     */
    @ManyToMany(fetch = FetchType.EAGER, mappedBy = "groups")
    @JsonIgnore
    private Set<User> clients = new HashSet<>();

    /**
     * Set of lessons associated with this study group.
     *
     * The 'lessons' field represents a many-to-many relationship between Group and Lesson entities,
     * fetch type EAGER - data always have adding to model during call it.
     * This field is marked to be ignored by JSON serialization.
     */
    @ManyToMany(fetch = FetchType.EAGER, mappedBy = "groups")
    @JsonIgnore
    private Set<Lesson> lessons = new HashSet<>();

    /**
     * The date and time when the study group was registered.
     *
     * This field is mapped to a column in the database with a timestamp and cannot be null.
     */
    @Temporal(value = TemporalType.TIMESTAMP)
    @Column(name = "register_date", nullable = false)
    private LocalDateTime registerDate;

    /**
     * Default constructor required by JPA.
     * Initializes a new instance of the Group class.
     */
    public Group() { }

    /**
     * Constructor for creating a Group with specified details.
     *
     * @param name The name of the study group
     * @param clients The set of users associated with the study group
     */
    public Group(
            String name,
            Set<User> clients
    ) {
        this.name = name;
        this.clients = clients;
    }

    /**
     * Automatically sets the registration date before persisting the entity.
     *
     * This method is invoked by JPA before saving the entity to the database.
     */
    @PrePersist
    protected void onCreate() {
        this.setRegisterDate(LocalDateTime.now());
    }

    /**
     * Adds a user to the group.
     *
     * @param client The user to be added
     * @return True if the user was added successfully, otherwise false
     */
    public boolean addClient(User client) {
        return clients.add(client);
    }

    /**
     * Removes a user from the group.
     *
     * @param user The user to be removed
     * @return True if the user was removed successfully, otherwise false
     */
    public boolean removeClient(User user) {
        return clients.remove(user);
    }

    /**
     * Gets the unique identifier of the study group.
     *
     * @return The unique identifier of the study group
     */
    public Long getId() {
        return id;
    }

    /**
     * Sets the unique identifier of the study group.
     *
     * @param id The unique identifier to set
     */
    public void setId(Long id) {
        this.id = id;
    }

    /**
     * Gets the name of the study group.
     *
     * @return The name of the study group
     */
    public String getName() {
        return name;
    }

    /**
     * Sets the name of the study group.
     *
     * @param name The name to set
     */
    public void setName(String name) {
        this.name = name;
    }

    /**
     * Gets the set of users associated with the study group.
     *
     * @return The set of users associated with the study group
     */
    public Set<User> getClients() {
        return clients;
    }

    /**
     * Sets the set of users associated with the study group.
     *
     * @param clients The set of users to set
     */
    public void setClients(Set<User> clients) {
        this.clients = clients;
    }

    /**
     * Gets the set of lessons associated with the study group.
     *
     * @return The set of lessons associated with the study group
     */
    public Set<Lesson> getLessons() {
        return lessons;
    }

    /**
     * Sets the set of lessons associated with the study group.
     *
     * @param lessons The set of lessons to set
     */
    public void setLessons(Set<Lesson> lessons) {
        this.lessons = lessons;
    }

    /**
     * Gets the registration date and time of the study group.
     *
     * @return The registration date and time of the study group
     */
    public LocalDateTime getRegisterDate() {
        return registerDate;
    }

    /**
     * Sets the registration date and time of the study group.
     *
     * @param registerDate The registration date and time to set
     */
    public void setRegisterDate(LocalDateTime registerDate) {
        this.registerDate = registerDate;
    }

    /**
     * Compares this Group instance with another object for equality.
     *
     * This method considers two Group instances equal if their IDs, names,
     * associated clients, lessons, and registration dates are all equal.
     *
     * It uses `EntityUtils.areCollectionsEqual` to compare the collections of clients
     * and lessons based on their IDs, to handle potential cyclical references.
     *
     * @param o the object to be compared with this instance
     * @return true if the objects are considered equal; false otherwise
     */
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Group group = (Group) o;

        return Objects.equals(id, group.id) &&
                Objects.equals(name, group.name) &&
                Objects.equals(registerDate, group.registerDate)
        ;
    }

    /**
     * Computes the hash code for this Group instance.
     *
     * The hash code is calculated based on the unique ID, name, collections of clients
     * and lessons (extracted using their IDs), and registration date. This ensures that
     * two Group instances with the same properties will have the same hash code.
     *
     * It uses `EntityUtils.extractIds` to extract IDs from the collections of clients and
     * lessons, which is useful for generating a consistent and accurate hash code.
     *
     * @return the hash code value for this instance
     */
    @Override
    public int hashCode() {
        return Objects.hash(
                id,
                name,
                registerDate
        );
    }

}

